*/GILBERTM JOB (ACCT#),STRING,
*/ NOTIFY=&SYSUID,
*/ CLASS=A,MSGCLASS=X,COND=(0,NE)
*/ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,
*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3
*/ NOBATCH)
***********************************************************************
*                                                                     *
* MACRO NAME = STRING                                                 *
*                                                                     *
* DESCRIPTIVE NAME = STRING Macro Instruction.                        *
*                                                                     *
* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *
*            or STRING (of COBOL) to assembler programs.              *
*                                                                     *
* STATUS = R616                                                       *
*                                                                     *
* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *
*                                                                     *
* ENVIRONMENT = SEE BELOW                                             *
*                                                                     *
*     AMODE = ANY                                                     *
*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *
*     KEY   = ANY                                                     *
*     MODE  = ANY                                                     *
*     APF   = ANY                                                     *
*                                                                     *
* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *
*                                                                     *
* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *
*                                                                     *
* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *
*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *
*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *
*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *
*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *
*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *
*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *
*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *
*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *
*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *
*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *
*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *
*        BLANKS NO LONGER USED OR GENERATED                           *
*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *
*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *
*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *
*        -  ADD SUPPORT FOR AR MODE                                   *
*        -  @STRING now executes in caller's AMODE                    *
*        -  Rename previous version to STRINGXA                       *
*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *
*        IMPROVE SUPPORT FOR AR MODE                                  *
*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *
*  $505  Allow for 128K-offset                                        *
*  $506  Remove literal from BAL instruction for HLASM R3             *
*  $507  Merge STRINGXA code, add AR_MODE option                      *
*        Change syntax of GENERATE call                               *
*  $508  Compatibility with FLAG(PAGE0) in HLASM R3                   *
*        Compatibility with pre-XA version of the SAVE macro          *
*        Remove AMODE-based R2 cleanup in 370 mode                    *
*  $509  Length of parm-list entries can vary between 2 and 6 bytes   *
*        Short Literals (one to five bytes) are generated in parm list*
*        Hex string can contain commas, e.g. X'12,3456,7890'          *
*  $510  JDATE=90366 produces 90/13/01 instead of S0C7                *
*  $511  Prevent ACTR error with long literals                        *
*  $512  Packed fields no longer ignored when R0=0                    *
*  $613  Basic support for z/Architecture (compat)              RS0306*
*  $614  Name changed to STRING64                               RS0306*
*        - Require a 64bit SaveArea (36F) (not compat !!!)      RS0306*
*          Format F4SA                                          RS0306*
*        - Support for FD                                       RS0306*
*        - R&I instruction                                      RS0306*
*        - Start using grande register                          RS0306*
*        - AR_MODE is now the default                           RS0306*
*        - z/Architecture required                              RS0306*
*  $615  64bit register display                                 RS0207*
*        - Support for AD                                       RS0207*
*  $616  Allow for 2G offset                                    RS0909*
*  $617  Merge fixes from STRING (GSF) 513-515                  RS0909*
***********************************************************************
         MACRO
&NAME    STRING64 &INTO=,&PRINT=GEN
         GBLC  &STRING_MACRO_VERSION
&STRING_MACRO_VERSION SETC '617'       current version          RS0909
         GBLA  &SYSALVL                ARCHLVL 0,1,2            RS0306
         GBLC  &SYSAM64                AMODE64 YES/NO           RS0306
         SYSSTATE TEST                 Test SYSSTATE            RS0306
         LCLC  &BAS                    BAS or BRASL             RS0306
         AIF   (&SYSALVL GT 1).ALVL1A  ARCHLVL greater 1 ?      RS0306
         AIF   ('&SYSAM64' EQ 'YES').ALVL1A AMODE64 YES ?       RS0306
&BAS     SETC  'BAS'                   Default                  RS0306
         AGO   .ALVL1B                 jump around              RS0306
.ALVL1A  ANOP                                                   RS0306
&BAS     SETC  'BRASL'              Archlvl gt 1 or AMODE64=YES RS0306
.ALVL1B  ANOP
         AIF   ('&PRINT' EQ 'NOGEN').NOGEN
         PUSH  PRINT
         PRINT GEN
.NOGEN   GBLA  &$_LIT
         GBLB  &$_FEAT(16)             FEATURES
.*                                       1 LITERALS
.*                                       2 REGISTER (BIN)
.*                                       3 REGISTER (HEX)
.*                                       4 PACKED
.*                                       5 JDATE
.*                                       6 BINARY
.*                                       7 HEX
.*                                       8 NUMERIC
.*                                       9 LEFT JUST (NUMERIC)
.*                                       10 LEADING ZEROES
.*                                       11 TRUNCATE (CHAR STRING)
.*                                       12 %TIME
         GBLC  &$_LITS(9999)           LITERALS
         LCLA  &I,&J,&L,&N,&FLAG,&LEN2,&STRBLANKS
         LCLC  &LABEL,&LQ,&STR,&TO1,&TO2,&P1S,&P2C,&P2L,&P3C,&P3L
         LCLC  &LIT,&ALLFEAT,&OPT2,&OPT3
         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X
               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL
&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS
&LQ      SETC  'L'''                   LENGTH ATTRIBUTE
&STR     SETC  '  R&STRING_MACRO_VERSION'
&NAME    &BAS  R14,$STRING&STR         CALL @STRING SUB-ROUTINE
         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR
         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR
         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)
         DC    AL4(&LABEL.P-*)         OFFSET TO FIELD DESCR.    RS0909
         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP
$LTORG   LOCTR                         ADDRESSABLE CONSTANTS
$FARRTNE LOCTR                         FAR ROUTINES
.LOCTR2  ANOP
$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS
&TO1     SETC  '&INTO(1)'
&TO2     SETC  '&LQ&INTO'
         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX
         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)
&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)
.PUNTO3  ANOP
&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)
         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)
&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))
.PUNTO8  ANOP
&LABEL.P DC    S(&TO1,&TO2)
.*--------------------------------------------------------------------*
.*-------      FIELDS       ------------------------------------------*
.*--------------------------------------------------------------------*
         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC,&NUMERIC
&I       SETA  1
.*LOOP
.LOOP1   ANOP
         ACTR  200                            SYSDEBUG/DIAG055
         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS
&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP
         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00
         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01
.*--------------------------------------------------------------------*
.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *
.*--------------------------------------------------------------------*
&P1S     SETC  '&SYSLIST(&I,1)'
&P2L     SETC  '0'                     INPUT LENGTH
&P3L     SETC  '0'                     OUTPUT LENGTH
         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES
         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME
         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)
         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250
&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)
.FLD115  ANOP
.*
         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200
.*
.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)
.*
&L       SETA  1
.*--LOOP
.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133
&L       SETA  &L+1
         AIF   (&L LT K'&P1S).FLD131
.*--ENDLOOP
&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF
         AGO   .FLD134
.FLD133  ANOP
&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE
.FLD134  ANOP
.*
         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200
.*
         AIF   (NOT D'&P2L).FLD140
&P2C     SETC  T'&P2L
.*MNOTE *,'&P1 &P2C'
         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220
         AIF   ('&P2C' EQ 'FD').FLD220  FD                       RS0306
         AIF   ('&P2C' EQ 'AD').FLD220  AD                       RS0207
         AIF   ('&P2C' EQ 'G').FLD210  FL2
.FLD140  ANOP
.*
.*       EXTRACT PSATOLD FROM PSATOLD-PSA
.*
&L       SETA  1
.*--LOOP
.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143
         AIF   ('&P2L'(&L,1) EQ '+').FLD143
&L       SETA  &L+1
         AIF   (&L LT K'&P2L).FLD141
.*--ENDLOOP
&P2L     SETC  '&LQ&P2L'               L'ABCDEF
         AGO   .FLD300
.FLD143  ANOP
&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA
         AGO   .FLD300
.*
.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800
&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12
         AIF   (&LAST).FLD186
         DC    X'60',AL1(&P2L)         BLANKS
         AGO   .LIT90
.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS
         AGO   .LIT90
.*
.FLD190  ANOP                          %TIME
&P1S     SETC  '1(14)'                 %TIME
&$_FEAT(12) SETB 1                     %TIME
         AGO   .FLD800
.*--------------------------------------------------------------------*
.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *
.*--------------------------------------------------------------------*
.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED
&P2C     SETC  '&SYSLIST(&I,2)'
         AGO   .FLD220
.*T'&P1=G
.FLD210  ANOP
&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'
&P2C     SETC  'FL&L'                  T'&P1 = 'G'
.*
.FLD220  ANOP
&P2L     SETC  '0&P2C'                 (R2) LENGTH
         AIF   ('&P2C'(1,1) EQ '(').FLD300
&P2L     SETC  '&P2C'                  3(R2) LENGTH
         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300
&P2L     SETC  '0'
&PACKED  SETB  ('&P2C' EQ 'P')
         AIF   (&PACKED).FLD290
&P2L     SETC  '1'
         AIF   ('&P2C' EQ 'FL1').FLD240
&P2L     SETC  '3'
         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240
&P2L     SETC  '7'
         AIF   ('&P2C' EQ 'FL3').FLD240
&P2L     SETC  '15'
         AIF   ('&P2C' EQ 'F').FLD240
&P2L     SETC  '31'                                              RS0306
         AIF   ('&P2C' EQ 'FD').FLD240                           RS0306
         AIF   ('&P2C' EQ 'AD').FLD240                           RS0207
&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD
         AGO   .FLD300
.*
.FLD240  ANOP                          BINARY VARIABLE
&BIN     SETB  1
         AGO   .FLD300
.*
.FLD250  ANOP                          REGISTER CONTENT
&REG     SETB  1
         AGO   .FLD300
.*
.FLD290  ANOP                          PACKED
&P2L     SETC  '1'
.*--------------------------------------------------------------------*
.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *
.*--------------------------------------------------------------------*
.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800
&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL
&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE
         AIF   (&HEX OR &TRUNC).FLD800
.*
&P3C     SETC  '&SYSLIST(&I,3)'
&P3L     SETC  '248'
         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308
&P3L     SETC  '249'
         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308
&P3L     SETC  '250'
         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308
&P3L     SETC  '251'
         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308
&P3L     SETC  '252'
         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308
&P3L     SETC  '253'
         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308
&P3L     SETC  '0'
         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310
         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'
         AGO   .FLD310
.FLD308  ANOP
&$_FEAT(5) SETB 1                      JDATE
         AGO   .FLD800
.*--LOOP
.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) NE 'L').FLD311
&LEFT    SETB  1
         AGO   .FLD318
.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312
&ZERO    SETB  1
         AGO   .FLD318
.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993       nn in RnnB is not num
         AIF   ('&P3C'(1,1) GT '9').FLD993       nn in RnnB is not num
&P3L     SETC  '&P3L'.'&P3C'(1,1)
.FLD318  ANOP
.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'
&P3C     SETC  '&P3C '(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER
         AIF   (K'&P3C GT 0).FLD310
.*--ENDLOOP
         AIF   (&P3L GT 16).FLD993               nn in RnnB is too big
.*--------------------------------------------------------------------*
.FLD800  ANOP
&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))
&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))
&LEFT    SETB  (&LEFT AND &NUMERIC)
         AIF   (NOT &NUMERIC).FLD810
         AIF   (&LEFT OR '&P3L' NE '0').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))
         AIF   (&REG).FLD810
&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'FL1').FLD810
&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810
&P3L     SETC  '31'                    DEFAULT OUTPUT LENGTH     RS0306
         AIF   ('&P2C' EQ 'FD').FLD810                           RS0306
         AIF   ('&P2C' EQ 'AD').FLD810                           RS0207
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH
.FLD810  ANOP
         AIF   (NOT &REG AND NOT &HEX).FLD811                    RS0207
         AIF   ('&SYSLIST(&I,1)'(1,2) NE '(G').FLD811 no grande reg
&P3L     SETC  '16'                                              RS0207
.FLD811  ANOP                                                    RS0207
&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1
&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L
&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)
&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)
&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED
&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY
&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX
&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED
&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))
&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)
&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)
&BIN     SETB  0                    RESET FLAGS
&HEX     SETB  0                    RESET FLAGS
&REG     SETB  0                    RESET FLAGS
&PACKED  SETB  0                    RESET FLAGS
&LEFT    SETB  0                    RESET FLAGS
&ZERO    SETB  0                    RESET FLAGS
&TRUNC   SETB  0                    RESET FLAGS
         AIF   (&FLAG GE 10).FLD995
         AIF   (&LAST).FLD816
         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)
         AGO   .LIT99
.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)
         AGO   .LIT99
.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'
         AGO   .LIT99
.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''
         AGO   .LIT99
.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'
         AGO   .LIT99
.*--------------------------------------------------------------------*
.*------------ LITERALS ----------------------------------------------*
.*--------------------------------------------------------------------*
.LIT00   ANOP
&LIT     SETC  'C&SYSLIST(&I)'
         AGO   .LIT09
.LIT01   ANOP
&LIT     SETC  '&SYSLIST(&I)'
.LIT09   ANOP                              calculate length of literal
&J       SETA  3
&L       SETA  0
         ACTR  K'&LIT+K'&LIT+100
         AIF   ('&LIT'(1,1) EQ 'X').LIT11X
.*LOOP
.LIT11C AIF ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&'(1,1)).LIT12C
&J       SETA  &J+1
.LIT12C  ANOP
&J       SETA  &J+1
&L       SETA  &L+1
         AIF   (&J LT K'&LIT).LIT11C
.*ENDLOOP
         AGO   .LIT15
.*LOOP
.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X
&L       SETA  &L+1
.LIT12X  ANOP
&J       SETA  &J+1
         AIF   (&J LT K'&LIT).LIT11X
.*ENDLOOP
&L       SETA  (&L+1)/2
.LIT15   ANOP                               generate in-line literal
         AIF   (&L GT 5).LIT40
         AIF   (&LAST).LIT16
         DC    X'4&L',&LIT
         AGO   .LIT90
.LIT16   DC    X'C&L',&LIT,0S(0)
         AGO   .LIT90
.LIT40   ANOP                                  check literal table
         AIF   (&$_LIT EQ 0).LIT50
&N       SETA  1
         ACTR  &$_LIT*3+200
.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP
&N       SETA  &N+1                                  LOOP
         AIF   (&N LE &$_LIT).LIT41                  LOOP
.LIT50   ANOP
&$_LIT   SETA  &$_LIT+1
&$_LITS(&$_LIT) SETC '&LIT'
&N       SETA  &$_LIT
.LIT80   ANOP                               generate remote literal
&N       SETA  &N+1000
         AIF   (&LAST).LIT86
         DC    X'40',AL1(&L),AL2($LIT&N-*)
         AGO   .LIT90
.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)
.LIT90   ANOP
&$_FEAT(1) SETB 1                      LITERAL
.LIT99   ANOP
.*--------------------------------------------------------------------*
&I       SETA  1+&I                              LOOP
         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP
.*ENDLOOP
&SYSLOC  LOCTR
         AGO   .MEND
.ERR1    MNOTE 12,'At least one Input Field must be specified'
         AGO   .MEND
.ERR2    MNOTE 12,'Invalid Output Area Specification'
         AGO   .MEND
.**********************************************************************
.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *
.**********************************************************************
.GENL    ANOP
         AIF   (N'&SYSLIST(1) GT 3).GENL1R
&OPT2    SETC  '&SYSLIST(1,2)'
         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X
               AND '&OPT2' NE 'NO_CSECT').GENL1R
&OPT3    SETC  '&SYSLIST(1,3)'
         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R
         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R
         AGO   .GENL1D
.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'
&OPT2    SETC  ''
&OPT3    SETC  ''
.GENL1D  ANOP
&STRBLANKS SETA 2
         AIF   (D'$LTORG).GENL1F             CSECT-ONLY
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1
.GENL1F  ANOP
&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'
&STR     SETC  '&STRING_MACRO_VERSION'
         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'
         AIF   (&$_LIT EQ 0).GENL3
$LITERAL LOCTR
.GENL2   ANOP                                LOOP
&N       SETA  &N+1                          LOOP
&I       SETA  &N+1000                       LOOP
$LIT&I   DC    &$_LITS(&N)
         AIF   (&N LT &$_LIT).GENL2          LOOP
.GENL3   ANOP
         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8
.**********************************************************************
.*                                                                    *
.*       STRING SUB-ROUTINE                                           *
.*                                                                    *
.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *
.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *
.*                                                                    *
.**********************************************************************
         AIF   ('&OPT3' EQ 'LOCTR').GENL4L
@STRING  CSECT
@STRING  RMODE ANY
         AGO   .GENL4X
.GENL4L  PUSH  USING                   GENERATE,LOCTR
         DROP
@STRING@ LOCTR
@STRING  DS    0H                      ALIGNMENT
.GENL4X  ANOP
@00      EQU   0                       WORK REGISTER
@01      EQU   1                       WORK REGISTER
@02      EQU   2                       WORK REGISTER
@03      EQU   3                       WORK REGISTER
@04      EQU   4                       WORK REGISTER
@05      EQU   5                       WORK REGISTER
@06      EQU   6                       WORK REGISTER
@07      EQU   7                       WORK REGISTER
@08      EQU   8                       WORK REGISTER
@09      EQU   9                       WORK REGISTER
@10      EQU   10                      WORK REGISTER
@11      EQU   11                      WORK REGISTER
@12      EQU   12                      WORK REGISTER
@13      EQU   13                      CALLER'S SAVE AREA
@14      EQU   14                      WORK REGISTER
@15      EQU   15                      BASE REG
         USING @STRING,@15
         USING @STRSAVE,@13
         J     @STR003                 BRANCH AROUND EYE-CATCHER
         DC    C'@STRING64/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'
@STR002  DC    H'4'                                              RS0909
@STR003  STMG  @14,@12,8(@13)          SAVE REGS (DEBUGGING ONLY)RS0306
         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET
         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS
         AHI   @14,-4            adjust addr of parm list offset RS0909
         LAE   @06,0                   R6=0 AR6=0
         CPYA  @14,@06                 AR14=0
         CPYA  @15,@06                 AR15=0
&LAE     SETC  'LAE'
         ICM   @06,B'1111',0(@14)      pick up parm list offset  RS0909
         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST
         USING @STRSCON,@06
         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         &BAS  @14,@STRS2A             GET ADDRESS IN R2
         &LAE  @04,0(,@02)             KEEP ADDRESS OF "INTO" FIELD
         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO
         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         &BAS  @14,@STRS2A             GET LENGTH IN R2
         LR    @05,@02                 KEEP LENGTH OF "INTO" FIELD
         CR    @05,@04                 END ADDRESS?
         JL    @STR282                 NO, JUMP
         SR    @05,@04                 CALCULATE LENGTH
@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK
.**********************************************************************
.*       MOVE FIELDS TO OUTPUT AREA                                   *
.**********************************************************************
         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC
         USING @STRPARM,@06
.*LOOP
@STR310  EQU   *
         AIF   (NOT &$_FEAT(1)).FEAT1A
         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?
         JO    @STR372                 YES, JUMP
.FEAT1A  ANOP
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A
         TM    @STRFLAG,@STRREG        REGISTER?
         JO    @STR323                 YES, JUMP
.FEAT23A ANOP
         AIF   (NOT &$_FEAT(12)).FEAT12A
         CLI   @STRSCON,X'E0'          IS IT %TIME ?
         BE    @STR378                 YES, JUMP
.FEAT12A ANOP
.*
.*       IT'S A FIELD (SCON)
.*
         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         &BAS  @14,@STRS2A             GET LENGTH IN R2
         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)
         LTR   @03,@02                 KEEP/TEST LENGTH
         JZ    @STR398                 ZERO LENGTH, DO NOT EDIT
         AGO   .FEAT9E2
.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH
         JP    @STR313                 LENGTH POSITIVE, JUMP
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         JNO   @STR398                 NO, ZERO LENGTH IS NOT OK
@STR313  EQU   *
.FEAT9E2 ANOP
         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         &BAS  @14,@STRS2A             GET ADDRESS IN R2
         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO
         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         CR    @03,@02                 END ADDRESS?
         JL    @STR314                 NO, JUMP
         LA    @00,X'0080'             PSA ADDRESS
         CLR   @02,@00                 PSA REFERENCE?
         JL    @STR314                 YES, JUMP
         SR    @03,@02                 CALCULATE LENGTH
@STR314  EQU   *
         AIF   (NOT &$_FEAT(6)).FEAT6A
         TM    @STRFLAG,@STRBIN        BINARY FIELD?
         JO    @STR328                 YES, JUMP
.FEAT6A  ANOP
         AIF   (NOT &$_FEAT(4)).FEAT4A
         TM    @STRFLAG,@STRPACK       PACKED FIELD?
         JO    @STR351                 YES, JUMP
.FEAT4A  ANOP
         AIF   (NOT &$_FEAT(7)).FEAT7A
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         JO    @STR376                 YES, JUMP
.FEAT7A  ANOP
.*
.*       TRUNCATE CHARACTER STRING
.*
         AIF   (NOT &$_FEAT(11)).FEAT11A
         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN
         JNE   @STR390                 NO STRING TRUNCATION, JUMP
         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD
@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP
         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP
         JNE   @STR390                 LAST NON-BLANK BYTE         LOOP
         BRCT  @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP
         J     @STR398                 BLANK FIELD, DO NOT EDIT
         AGO   .FEAT11B
.FEAT11A ANOP
         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B
         J     @STR390                 EDIT
.FEAT11B ANOP
.*
.*       REGISTER (R0-R13)
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B
@STR323  DS    0H                                                RS0207
         LH    @01,@STRSCON            REG NUMBER IN BITS 28-31  RS0207
         CLI   @STRLEN2,X'10'          Mask eq 16 (grand reg)?   RS0207
         JNE   @STR325                   yes use                 RS0207
         CLI   @STRSCON+1,@06          IS THIS R7-R13?
         JH    @STR323R                YES, JUMP
         LR    @07,@01                 SAVE R1 (R)
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREGG @00,@06                 RELOAD CALLER'S R0-R6     RS0207
*        EX    @07,@STR323L            COPY R0-R6 VALUE          RS0207
         CHI   @07,0                   EX doesn't work with LGR  RS0207
         JE    @STR323G                                          RS0207
         CHI   @07,1                                             RS0207
         JNE   @STR323A                                          RS0207
         LGR   @00,@01                                           RS0207
         J     @STR323G                                          RS0207
@STR323A DS    0H                                                RS0207
         CHI   @07,2                                             RS0207
         JNE   @STR323B                                          RS0207
         LGR   @00,@02                                           RS0207
         J     @STR323G                                          RS0207
@STR323B DS    0H                                                RS0207
         CHI   @07,3                                             RS0207
         JNE   @STR323C                                          RS0207
         LGR   @00,@03                                           RS0207
         J     @STR323G                                          RS0207
@STR323C DS    0H                                                RS0207
         CHI   @07,4                                             RS0207
         JNE   @STR323D                                          RS0207
         LGR   @00,@04                                           RS0207
         J     @STR323G                                          RS0207
@STR323D DS    0H                                                RS0207
         CHI   @07,5                                             RS0207
         JNE   @STR323E                                          RS0207
         LGR   @00,@05                                           RS0207
         J     @STR323G                                          RS0207
@STR323E DS    0H                                                RS0207
         CHI   @07,6                                             RS0207
         JNE   @STR323F                                          RS0207
         LGR   @00,@06                                           RS0207
         J     @STR323G                                          RS0207
@STR323F DS    0H                                                RS0207
         DC    H'0'                    force abend               RS0207
@STR323G DS    0H                                                RS0207
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         J     @STR325T                                          RS0207
*@STR323L LGR   @00,*-*                 COPY VALUE FOR EDIT      RS0207
@STR323R EQU   *                                                 RS0207
         EREGG @07,@12                 RESTORE CALLER'S R7-R12   RS0207
*        EX    @01,@STR323L            COPY R7-R13 INTO R0       RS0207
         CHI   @01,7                   ex doesn't work with LGR  RS0207
         JNE   @STR323H                                          RS0207
         LGR   @00,@07                                           RS0207
         J     @STR325T                                          RS0207
@STR323H DS    0H                                                RS0207
         CHI   @01,8                                             RS0207
         JNE   @STR323I                                          RS0207
         LGR   @00,@08                                           RS0207
         J     @STR325T                                          RS0207
@STR323I DS    0H                                                RS0207
         CHI   @01,9                                             RS0207
         JNE   @STR323J                                          RS0207
         LGR   @00,@09                                           RS0207
         J     @STR325T                                          RS0207
@STR323J DS    0H                                                RS0207
         CHI   @01,10                                            RS0207
         JNE   @STR323K                                          RS0207
         LGR   @00,@10                                           RS0207
         J     @STR325T                                          RS0207
@STR323K DS    0H                                                RS0207
         CHI   @01,11                                            RS0207
         JNE   @STR323L                                          RS0207
         LGR   @00,@11                                           RS0207
         J     @STR325T                                          RS0207
@STR323L DS    0H                                                RS0207
         CHI   @01,12                                            RS0207
         JNE   @STR323M                                          RS0207
         LGR   @00,@12                                           RS0207
         J     @STR325T                                          RS0207
@STR323M DS    0H                                                RS0207
         CHI   @01,13                                            RS0207
         JNE   @STR323N                                          RS0207
         LGR   @00,@13                                           RS0207
         J     @STR325T                                          RS0207
@STR323N DS    0H                                                RS0207
         DC    H'0'                    force abend               RS0207
         J     @STR325T                                          RS0207
@STR325  DS   0H                                                 RS0207
         CLI   @STRSCON+1,@06          IS THIS R7-R13?           RS0207
         JH    @STR325R                YES, JUMP                 RS0207
         LR    @07,@01                 SAVE R1 (R)               RS0207
         LAE   @10,0(,@04)             SAVE R4                   RS0207
         LR    @11,@05                 SAVE R5                   RS0207
         LAE   @12,0(,@06)             SAVE R6                   RS0207
         EREG  @00,@06                 RELOAD CALLER'S R0-R6     RS0207
         EX    @07,@STR325L            COPY R0-R6 VALUE          RS0207
         LAE   @04,0(,@10)             RESTORE R4                RS0207
         LR    @05,@11                 RESTORE R5                RS0207
         LAE   @06,0(,@12)             RESTORE R6                RS0207
         J     @STR325T                                          RS0207
@STR325L LR    @00,*-*                 COPY VALUE FOR EDIT       RS0207
@STR325R EQU   *                                                 RS0207
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    @01,@STR325L            COPY R7-R13 INTO R0       RS0207
@STR325T EQU   *                                                 RS0207
         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX
         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         JNO   @STR330                 NO, EDIT FWD
.FEAT2H  ANOP
         SR    @03,@03                 clear R3                  RS0207
         ICM   @03,B'0001',@STRLEN2    Length present ?          RS0207
         JZ    @STR325U                   Yes use it             RS0207
         STCMY @00,B'1111',@STRDWD+3   STORE IT FOR CVD/UNPK     RS0207
         STCMH @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK     RS0207
         J     @STR325V                                          RS0207
@STR325U EQU   *                                                 RS0207
         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK
         LA    @03,8                   OUTPUT LENGTH
@STR325V EQU   *                                                 RS0207
         J     @STR376X                EDIT IN HEX
.FEAT3R  ANOP
         AIF   (NOT &$_FEAT(6)).FEAT23B
         J     @STR330                 EDIT R0
.FEAT23B ANOP
.*
.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)
.*
         AIF   (NOT &$_FEAT(6)).FEAT6B
@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**
@STR328  SLR   @00,@00
         CHI   @03,15                  Mask GT 15                RS0306
         JH    @STR329                   yes use CVDG            RS0306
         EX    @03,@STR328M            LOAD THE BINARY VARIABLE
         J     @STR329E                                          RS0306
@STR329  LG    @00,0(@02)                                        RS0306
         CVDG  @00,@STRDWD                                       RS0306
         J     @STR361                                           RS0306
@STR329E DS    0H                                                RS0306
.FEAT6B  ANOP
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C
@STR330  XC    @STRDWD(8),@STRDWD      clear first part          RS0306
         CVD   @00,@STRDWD+8           CONVERT VALUE TO DECIMAL  RS0306
         AIF   (NOT &$_FEAT(4)).FEAT6C
         J     @STR361                 EDIT DWD
.FEAT6C  ANOP
.*
.*       PACKED FIELD
.*
         AIF   (NOT &$_FEAT(4)).FEAT4B
@STRZAP  ZAP   @STRDWD(16),0(*-*,@02)      MOVE TO @STRDWD       RS0306
@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD
         BALR  @14,0
         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?
         LA    @03,1(,@03)              (NEXT BYTE)
         BNOR  @14                     NO, LOOP MORE
         SLR   @03,@02                 GET LENGTH OF PACKED FIELD
         BCTR  @03,0
         EX    @03,@STRZAP             EXECUTE ZAP
         AIF   (NOT &$_FEAT(5)).FEAT4B
         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?
         JNL   @STR375                 YES, JUMP
.FEAT4B  ANOP                          PACKED
.*
.*       EDIT @STRDWD (BIN, REG, PACKED)
.*
         AIF   (NOT &$_FEAT(8)).FEAT8B
@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH
         LA    @03,X'003F'             MASK FOR "AND"
         NR    @03,@00                 OUTPUT LENGTH
         MVC   @STRWK32(32),@STRMASK32 EDIT MASK                 RS0306
@STR362  EQU   *
.*
.*       LEFT-JUSTIFICATION (NUMERIC)
.*
         AIF   (NOT &$_FEAT(9)).FEAT9B
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         JNO   @STR367                 NO, JUMP
         &LAE  @01,@STRWK32+31         PREVENT BAD R1
         EDMK  @STRWK32(32),@STRDWD    ZONED DECIMAL
         BNM   @STR362A                skip if not a negative number
         BCTR  @01,0                   R1 = significance start ptr -1
         MVI   0(@01),C'-'             sink negative sign in front
@STR362A &LAE  @02,0(,@01)             FIRST STRING POSITION
         LTR   @03,@03                 CHECK OUTPUT LENGTH
         JNZ   @STR363                 JUMP IF NOT ZERO
.*       L0    (LEFT JUSTIFIED, NO PADDING)
         &LAE  @03,@STRWK32+32         1. POSITION AFTER STRING  RS0306
         SR    @03,@02                 COMPUTE STRING LENGTH
         J     @STR390                 MOVE FIELD TO OUTPUT LINE
.*       L1-L63 (LEFT JUSTIFIED, PADDING)
@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         JNH   @STR364                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 LENGTH WITH PADDING
         LA    @03,@STRWK32+32         1. POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         J     @STR392                 MOVE FIELD TO OUTPUT LINE
@STR367  EQU   *
.FEAT9B  ANOP
         AIF   (NOT &$_FEAT(10)).FEAT10B
         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?
         JNO   @STR368                 NO, JUMP
         MVI   @STRWK32,C'0'           YES, CHANGE X'40' TO C'0'
@STR368  EQU   *
.FEAT10B ANOP
         &LAE  @01,@STRWK32+31         PREVENT BAD R1
         EDMK  @STRWK32(32),@STRDWD    ZONED DECIMAL
         BNM   @STR369                 skip if not a negative number
         BCTR  @01,0                   R1 = significance start ptr -1
         MVI   0(@01),C'-'             sink negative sign in front
@STR369  &LAE  @02,@STRWK32+32         1. POSITION AFTER STRING
         SR    @02,@03                 FIRST STRING POSITION
.FEAT8B  ANOP
.*
.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)
.*       Short Literal (low-order 4 bits of @STRFLAG contains length)
.*       BLANKS  (@STRSCON=ZERO)
.*
         AIF   (NOT &$_FEAT(1)).FEAT1B
         J     @STR390                 MOVE STRING TO OUTPUT LINE
@STR372  LA    @01,7                   mask for NR
         &LAE  @02,@STRLEN2            1st byte of short literal
         IC    @03,@STRFLAG            pick up flags+length
         NR    @03,@01                 R3 has length of short literal
         JNZ   @STR390                 short literal, go move it
         SLR   @02,@02                 Clear Address Register
         IC    @03,@STRLEN2            GET LITERAL LENGTH
         TM    @STRFLAG,@STRX40        string of spaces?
         JO    @STR390                 yes, go move them
         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET
         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS
.FEAT1B  ANOP
.*
.*       CONVERT JULIAN DATE TO YYMMDD
.*
         AIF   (NOT &$_FEAT(5)).FEAT5F
         J     @STR390                 MOVE STRING TO OUTPUT LINE
@STR375  LA    @00,248                 MASK FOR 'SLR'
         SLR   @01,@01
         IC    @01,@STRLEN2            248-255
         SLR   @01,@00                 000-007
         LA    @00,12                  L'@STR375W
         MR    @00,@00                 COMPUTE OFFSET
         &LAE  @01,@STR375W(@01)       ENTRY IN "TR" MASK TABLE
         SLR   @03,@03
         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)
         ZAP   @STRDWD(16),@STRDWD(16)     DATE=0000000?
         JNZ   @STR375B                NO, JUMP                    @JDT
@STR375Z &LAE  @02,@STRBLANKS          WORK AREA
&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS
         J     @STR390                 MOVE FIELD TO OUTPUT LINE
@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248
         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249
         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250
         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251
         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252
         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253
.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254
.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255
@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'
         DC    P'999'                  Prevent S0C7 with 90366
@STR375B CLI   @STRDWD+12,X'01'         YEAR 2000 OR ABOVE?
         JH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)
         MVI   @STRDWD+12,X'20'         CC=01, CHANGE TO CC=20
         JE    @STR375C                CC=01, USE CC=20
         CLI   @STRDWD+12+1,X'50'       YY<50?
         JL    @STR375C                YES, USE CC=20
         MVI   @STRDWD+12,X'19'         NO, FORCE CC=19
@STR375C UNPK  @STRWK32(5),@STRDWD+12(3) CCYY?
         ZAP   @STRDWD+9(2),@STR375T+9(1) INIT MONTH COUNTER
         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)
         TM    @STRDWD+12+1,X'01'       ODD YEARS
         JO    @STR375N                  AREN'T LEAP YEARS
         TM    @STRDWD+12+1,X'12'      ZEROES IN 1980, ALL ONES IN 1992
         JNM   @STR375L                MIXED IN 1982/1990
.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD
@STR375N CP    @STRDWD+12+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?
         JNH   @STR375L                NO, JUMP
         AP    @STRDWD+12+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD
.*--LOOP WHILE DDD > 0
@STR375L AP    @STRDWD+9(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH
         LA    @02,2(,@02)             NEXT ENTRY IN "MONTHS" TABLE
         SP    @STRDWD+12+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD
         JP    @STR375L
.*--ENDLOOP
         AP    @STRDWD+12+2(2),0(2,@02) UNDO LAST "SP" INSTRUCTION
         UNPK  @STRWK32+4(2),@STRDWD+9(2) FYFYFYFY,FMCM??
         UNPK  @STRWK32+6(2),@STRDWD+14(2) FYFYFYFY,FMCMFDCD
         MVZ   @STRWK32+1(7),@STRWK32     FYFYFYFY,FMCMFDCD
         MVC   @STRWK32+8(1),1(@01)    SEPARATOR
         &LAE  @02,@STRWK32+9          WORK AREA
         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK
         TR    0(10,@02),@STRWK32      CONVERT DATE TO THE RIGHT FORMAT
.FEAT5F  ANOP                          JDATE
.*
.*       HEX STRING
.*
         AIF   (NOT &$_FEAT(7)).FEAT7B
         J     @STR390                 MOVE STRING TO OUTPUT LINE
@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK
@STR376  LA    @00,8                   MAX LENGTH
         CLR   @03,@00                 CHECK LENGTH
         JNH   @STR376B                JUMP IF LE 8
         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH
@STR376B LR    @01,@03                 INPUT LENGTH
         BCTR  @01,0
         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE
         ALR   @03,@03                 OUTPUT LENGTH
         AGO   .FEAT37B
.FEAT7B  ANOP
         AIF   (NOT &$_FEAT(3)).FEAT37C
         J     @STR390                 MOVE STRING TO OUTPUT LINE
.FEAT37B ANOP
@STR376X &LAE  @02,@STRWK32            WORK AREA
         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR "TR"
         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR "TR"
         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'
.FEAT37C ANOP
.*
.*       %TIME
.*
         AIF   (NOT &$_FEAT(12)).FEAT12B
         J     @STR390                 MOVE STRING TO OUTPUT LINE
@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX
@STR378  LR    @02,@15                 SAVE BASE REG
         TIME  DEC                     GET HHMMSSHH
         LR    @15,@02                 RESTORE BASE REG
         ST    @00,@STRDWD             STORE HHMMSSHH
         MVC   @STRWK32(13),@STRTIME   MOVE EDIT MASK
         ED    @STRWK32(13),@STRDWD    EDIT HH:MM:SS:HH
         &LAE  @02,@STRWK32+1          WORK AREA
         LA    @03,12                  HH:MM:SS:HH+ SPACE
.FEAT12B ANOP
.*MOVE
@STR390  DS    0H                                                RS0207
         CR    @03,@05                 COMPARE LENGTH TO REMAININGSLEN
         JNH   @STR391                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 PASS REMAINING LENGTH
         LTR   @02,@02                 BLANKS?
         JNZ   @STR392                 NO, JUMP
         SLR   @03,@03                 YES, ZERO LENGTH
@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS
         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE
         LR    @04,@08                 NEW POINTER IN OUTPUT LINE
@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR
         JO    @STR399                 Done, exit
         AIF   (NOT &$_FEAT(1)).FEAT1C
         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?
         JM    @STR398L                Literal, not spaces
         JZ    @STR398X                Neither literal nor spaces
         LA    @06,@STRSCON            2-byte entry for blank spaces
         J     @STR310                 PROCESS NEXT ENTRY
@STR398L LA    @01,7                   mask for NR
         IC    @03,@STRFLAG            pick up flags+length
         NR    @03,@01                 R3 has length of short literal
         JZ    @STR398T                not an in-line literal, jump
         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal
         J     @STR310                 PROCESS NEXT ENTRY
@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal
         J     @STR310                 PROCESS NEXT ENTRY
.FEAT1C  ANOP
@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY
         J     @STR310                 PROCESS NEXT ENTRY
.*ENDLOOP
.*
.*       END-OF-LINE PROCESSING - PAD WITH BLANKS
.*
@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING
         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING
.***     DROP  @06,@13,@15
         LA    @15,3                   MODIFIABLE AREA
         ESTA  @14,@15                 R14 = START OF OUTPUT AREA
         LR    @15,@04                 END OF OUTPUT AREA
         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA
         MVCL  @04,@00                 PAD WITH BLANKS
         EREG  @00,@14                 RESTORE WORK REGISTERS
         STMG  @14,@12,8(@13)          MAKE SAVE AREA LOOK NORMALRS0306
         OI    15(@13),1               SIMULATE "T" OPTION OF RETURN
         PR                            RETURN TO CALLER
.*
         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T
@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION
.FEAT37T ANOP
         AIF   (NOT &$_FEAT(8)).FEAT8T
@STRMASK32 DC    X'4020202020202020,2020202020202020'            RS0306
         DC    X'2020202020202020,2020202020202120'              RS0306
.FEAT8T  ANOP
.**********************************************************************
.*       Convert S-con to address                                     *
.*             Input: GPR2 points to an S-CON in the remote parm list *
.*             Output: GPR2 contains the address                      *
.**********************************************************************
@STRS2A  SLR   @00,@00
         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD
         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....
         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)
         SLL   @00,2                   MULT BY 4
         CLI   0(@02),@06*16+15        R7-R13?
         JH    @STRS2A6                YES, JUMP
.*BASE REG IS R0-R6
         LTR   @02,@00                 IS R0 THE BASE REG?
         JNZ   @STRS2A5                NO, JUMP
         LTR   @02,@01                 IS THIS A PSA ADDRESS?
         BNZR  @14                     YES, GOBACK
         EREG  @00,@00                 POP R0
         LAE   @02,0                   R2=0 AR2=0
         LR    @02,@00                 PASS R0 VALUE
         LA    @02,0(,@02)             CLEAN UP
         BR    @14                     GOBACK
.*BASE REG IS R1-R6
@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)
         LR    @08,@01                 SAVE R1 (DDD)
         LR    @09,@03                 SAVE R3
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @01,@06                 RELOAD CALLER'S R1-R6
         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL
         LR    @03,@09                 RESTORE R3
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         BR    @14                     GOBACK
.*BASE REG IS R7-R13
@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL
         BR    @14                     GOBACK
@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL
         AIF   ('&OPT3' EQ 'LOCTR').GENL7L
@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '
         AGO   .GENL7X
.GENL7L  ANOP
@STRBLANKS DC  CL&STRBLANKS.' '
.GENL7X  ANOP
@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT
         DROP  @06,@13,@15
.**********************************************************************
.*       WORK AREA (CALLER'S SAVE AREA)                               *
.**********************************************************************
@STRSAVE DSECT                         WORK AREA 144 Byte Savearea
         DS    A(0,@STRSAVE)
         DS    AD(14,15,0,1,2,3,4,5,6)
@STRWK32 DS    FD'7,8,9,10'            WORK AREA
@STRDWD  DS    FD'11,12'               WORK AREA                 RS0306
         DS    A(@STRSAVE,@STRSAVE)
@STRPARM DSECT
@STRFLAG DS    B                   +0  FORMAT, FLAGS
@STRLAST EQU   X'80'                     LAST ENTRY
@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET
@STRX40  EQU   X'20'                   String of Spaces
.*             X'0F'                   CONVERSION REQUIRED
.*                                     or length of short literal
@STRHEX  EQU   X'08'                     HEXADECIMAL
@STRBIN  EQU   X'04'                     BINARY
@STRPACK EQU   X'02'                     PACKED
@STRREG  EQU   X'01'                     REGISTER
@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH
.*                                     or start of short literal
@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION
@STRZERO EQU   X'40'                     LEADING ZEROES
.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.
@STRSCON DS    S                   +2  FIELD ADDRESS
@STRFLEN DS    S                   +4  FIELD LENGTH
@STRNEXT EQU   *                   +6
         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY
         AIF   (D'$STRING).MEND99      CSECT-ONLY
$LTORG   LOCTR
         AIF   ('&OPT3' EQ 'LOCTR').GENL9L
         CNOP  0,4
$STRING  BALR  @15,0                   LOCAL BASE
         L     @15,6(@15,0)            ROUTINE ADDRESS           00
         BR    @15                     GO TO @STRING             04
         AGO   .GENL9
.GENL8   ANOP                          GENERATE,NOCSECT
&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL
$LTORG   LOCTR
         CNOP  0,4
$STRING  BALR  R15,0                   LOCAL BASE
         L     R15,6(R15,0)            ROUTINE ADDRESS           00
         BR    R15                     GO TO @STRING             04
.GENL9   ANOP
         DC    V(@STRING)              ROUTINE ADDRESS           06
         AGO   .MEND
.GENL9L  POP   USING                   GENERATE,LOCTR
$STRING  BAS   R15,$STRING2
         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE
$STRING2 AH    R15,0(R15,0)
         BR    R15
.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99
         POP   PRINT
.MEND99  MEND
         EJECT
**********************************************************************
**********************************************************************
********* TEST PROGRAM FOR THE 'STRING' MACRO ************************
**********************************************************************
**********************************************************************
**       STRING (GENERATE,AR_MODE)
**       END
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
TESTPGM  START X'027000'
TESTPGM  AMODE 24                      (PRE-SMS PUT)
         BALR  R12,0
         USING *,R12
*LOAD EP=SYSDEBUG
*LR R15,R0
*BASSM R14,R15
*STRING641X,INTO=XXX
         OPEN  (SYSPRINT,OUTPUT)
         STRING64 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX
         PUT   SYSPRINT,XXX
RBPREFIX EQU   *
RBINTCOD EQU   *+6,2,C'H'
ASCBASID EQU   *+8,2,C'X'
         L     R1,PSATOLD-PSA(0,0)
         L     R1,0(,R1)               TCBRBP
         STRING64 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                 X
               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X
               ((R8),,X),1X,           COM-REG ADDR                    X
               (ASCBASID,,X),1X,       ASID                            X
               PARM1,1X,               MAIN PGM NAME                   X
               INTO=XXX
         PUT   SYSPRINT,XXX
*
         LA    R2,XXX
         STRING64 1X,INTO=((R2),8)
         MACRO                                       JDATE MACRO
        @JDATE &DATE                                 JDATE MACRO
         LA    R1,=P'&DATE'                          JDATE MACRO
*** STRING64((R1),P),2X,((R1),P),INTO=XXX
         STRING64 ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                X
               3X,((R1),P,YY/MM/DD),                                   X
               3X,((R1),P,DD/MM/YY),                                   X
               3X,((R1),P,MM/DD/YY),                                   X
               3X,((R1),P,YYYYMMDD),                                   X
               3X,((R1),P,YYYY-MM-DD)
         PUT   SYSPRINT,XXX                          JDATE MACRO
         MEND                                        JDATE MACRO
        @JDATE 90058
        @JDATE 91059
        @JDATE 93060
        @JDATE 94365
        @JDATE 80058
        @JDATE 84059
        @JDATE 88060
        @JDATE 92061
        @JDATE 00366
         LA    R2,1234
         STRING64 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,             X
               ' 1234=',((R2),,R4Z)
         PUT   SYSPRINT,XXX
         L     R1,CVTPTR(0,0)
         STRING64 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R0,1000
         LA    R3,0033
         STRING64 'D1=/',D1,'/,WWWW=/',WWWW,'/',                       X
               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X
               ((R3),,R9B),'/',INTO=XXX
         LR    R4,R15                   LENGTH USED
         PUT   SYSPRINT,XXX
         STRING64 WWWW,                                                X
               (4(R13),4,X),'''',(4(R13),F),'''',                      X
               (4(R13),F,L),'''',                                      X
               (4(R13),F,L11),'''',                                    X
               (4(R13),F,Z9),'''',                                     X
               8X,'R4=',((R4),,L),      LENGTH USED                    X
               INTO=XXX
         PUT   SYSPRINT,XXX
         STRING64 %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2, X
               INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R3,22
         STRING64 INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)
         PUT   SYSPRINT,XXX
         STRING64 C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                 +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
         AIF   ('&SYSVER' EQ 'ASMH').HLASM99
PSABASE  USING PSA,R0
         STRING64 'PSATOLD=',(PSABASE.PSATOLD,,X),                     +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
.HLASM99 ANOP
         BALR  R0,0
         STRING64 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX
         PUT   SYSPRINT,XXX
         STRING64 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX
         PUT   SYSPRINT,XXX
         SLR   R0,R0
         STRING64 'R0=',((R0),,X),'   CTR2=',(CTR2,P,L),INTO=XXX
         PUT   SYSPRINT,XXX
*
AMODE31  LA    R12,0(,R12)             BALR->BASR
         L     R15,=A(*+X'80000006')   AMODE=31
         BSM   0,R15                   AMODE=31
         L     R1,=A(@STRING)          point at CSECT
         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?
         BNE   EXIT                    no, prevent S0E0
         DSPSERV CREATE,                                               X
               NAME==CL8'STRING00',    C'STRING00'                     X
               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X
               STOKEN=DSPCSTKN,                                        X
               ORIGIN=DSPCORG
         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET
         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE
         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)
         SAC   512                     MODE=AR
 LAM R14,R6,TESTPGM+40                 S0E0-28
         STRING64 WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)
         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE
         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)
         STRING64 (2048+L'WWWW(R2),30,T),INTO=XXX
         SAC   0                       MODE=AR OFF
         PUT   SYSPRINT,XXX            AR_MODE WORKS OK
*
EXIT     SLR   R15,R15
         SVC   3                       GOBACK
D1       DC    C'D1-----D1    '
WWWW     DC    C'WWWW'
CTR1     DC    P'1'
CTR2     DC    P'-33'
PARM1    DC    C'<-PARM1->'
PARM2    DC    C'<-PARM2->'
XXX      DS    CL132
DSPCSTKN DS    XL8                  0  AS TOKEN
DSPCALET DS    F                    8  ALET
DSPCORG  DS    F                   12  ORIGIN
HDRBLKS  DC    F'100'
CVTPTR   EQU   0016,4,C'A'
SYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121
XYZ      DSECT
         STRING64 GENERATE
**       STRING (GENERATE,NO_CSECT) -\
**       STRING (GENERATE,AR_MODE)  -/
**       STRING (GENERATE,,LOCTR)
**       STRING (GENERATE,AR_MODE,LOCTR)
**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination
         YREGS
PSA      DSECT
PSATOLD  EQU   *+X'21C',4,C'A'
         END
//SYSPRINT DD SYSOUT=*
//*YSLIB   DD DISP=SHR,DSN=MVT.MACLIB           SAVE/GET          -DEL-
//*        DD DISP=SHR,DSN=SYS1.MACLIB                            -DEL-
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//GO      EXEC PGM=LOADER,PARM=PRINT TIME=(,9)
//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)
//SYSLOUT  DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//ABNLTERM DD SYSOUT=*
//ABNLIGNR DD DUMMY
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*

          +----------------------------------------+
          +                                        +
          +   Documentation for the STRING macro   +
          +                                        +
          +       Last update: 13 Dec 1999         +
          +----------------------------------------+

  The STRING macro is functionally similar to the COBOL DISPLAY
  or PL/I PUT EDIT instructions.

  Using STRING, you can concatenate any number of fields, edit
  each of them if necessary, and get the result in the work area
  you specify.

  Formats:

    (1) label  STRING {field_specification1}
                      {,field_specification2}...
                      ,INTO=workarea|(workarea,length)
                      {,PRINT=GEN|NOGEN}

    (2) label  STRING GENERATE
                      {,PRINT=GEN|NOGEN}


  field_specification

    Each field to be printed is described as a positional
    operand.  Each operand specifies the field address, its
    length, and its formatting requirements.

    Four field description formats are supported:

      1.   symbol
      2.   (symbol,length,format)
      3.   (d(r)|(r),length,format)
                                                                 RS0207
      4.   ((r),,format) or ((Gr),,format)                       RS0207
      5.   'character string'

  Symbol specifies the field address.  It must be an
    S-type (relocatable) address.

  d(r) may be used to specify the field address in S/370
    base-displacement format.  If d is zero, it may be omitted.
    If d(r) or (r) is used, length must also be specified.  R14
    and R15 may not be used.  If d(0) is used, it is handled the
    way the assembler does, i.e. R0 as a base register is assumed
    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.

  ((r),,format) specifies that (r) contains the value
    itself, not an address.  R14 and R15 may not be used.

  ((Gr),,format) specifies that (Gr) contains the value          RS0207
    itself, not an address.  GR14 and GR15 may not be used.      RS0207
    The display is the 64bit value                               RS0207

  'character string' specifies a literal enclosed in single quotes
    as specified in a DC instruction.  Hex strings or character
    strings are supported.  The following expressions are equivalent:
    'ABC' C'ABC' X'C1C2C3'

  Length specifies the length and/or the type of the input field.
    It may be specified as an integer, a symbol, a register, or a
    constant.  When used with symbol, it overrides the assembled
    length and/or type.  Length is required if field is specified
    as d(r) or (r).  If a zero length is specified, the field is
    ignored.

        nn   field length in bytes
        H    half-word
        F    full-word
        FL1  1-byte binary integer
        FL3  3-byte binary integer
        FD   Full-doubleword                                     RS0306
        P    packed field
        (r)  length of character string (R0 thru R12)
        d(r) length of character string (R1 thru R12)

  Notes:  If the field address is specified as a symbol that
          has been defined previously in the program, the symbol
          type is known and there is no need to specify it.

          If the length is specified as (r) or d(r) and the value
          is greater than the address itself, (r) or d(r) is
          considered to be the end address +1 instead of the length.

          The length is not specified for packed fields.  The
          @STRING subroutine scans the field left-to-right until it
          finds a byte with a valid sign in the low-order 4 bits.

          If symbol is an arithmetic expression and no length is coded,
          the implicit length will be that of the first symbol in the
          expression;  for example, if symbol is coded as PSATOLD-PSA,
          then the implicit length will be L'PSATOLD.

          All numeric items are assumed positive.

  format  optionally indicates editing options that must
          be applied to a field.

      L        left justified
      R        right justified
      nn       output length
      0        adjust length
      Z        leading zeroes
      B        leading/trailing blanks
      T        truncate character string after last non-blank
      X        display in hexadecimal
      YYMMDD   convert julian date to YYMMDD
      YY/MM/DD convert julian date to YY/MM/DD
      DD/MM/YY convert julian date to DD/MM/YY
      MM/DD/YY convert julian date to MM/DD/YY
      YYYYMMDD convert julian date to YYYYMMDD
      YYYY-MM-DD convert julian date to YYYY-MM-DD

    The default format depends on the field type:

        Type                   Default Format

        character string             L
        FL1                          R3B
        H or FL2                     R5B
        FD/AD                        R16B                        RS0207
        other numeric fields         R7B

    Note: L0 and T are equivalent for character strings.

  'character string' is any character string enclosed in
  single quotes.  Blank spaces may be specified as nnX,
  where nn is the number of X'40' bytes you want to be
  inserted in the output line.  %TIME may be specified to
  obtain the current time in hh.mm.ss.hh format.

INTO=workarea|(workarea,length)

  INTO indicates the address and length of the output work area
  into which the result of the concatenation should be placed
  (left justified).  If the work area is too small, truncation
  will occur.  If it is too large, it is padded with blanks.

  The address may be a symbol, d(r) (S-type address) or (r).

  The length may be specified as an integer, a symbol, a register,
  or a constant; it is required if the address is coded as d(r) or
  (r).  If length is not specified for a symbol-type address, the
  assembled length of the symbol is used.

  Upon return from STRING, R15 contains the length actually used
  in the output work area (before padding).

PRINT=GEN|NOGEN

  This operand allows you to temporarily override the PRINT
  specification (GEN or NOGEN).

GENERATE (format 2)

  The GENERATE format must be specified once at the end of the
  program.  It generates the @STRING sub-routine as well as all
  the literals specified in previous invocations of the macro.

  The GENERATE format allows the specifications of the
  AR_MODE, NO_CSECT and LOCTR options.

         STRING GENERATE<,AR_MODE<,LOCTR>>>
                          NO_CSECT

  The following combinations are valid:

         STRING GENERATE              obsolete AR_MODE is always on
         STRING (GENERATE,NO_CSECT)
         STRING (GENERATE,AR_MODE)
         STRING (GENERATE,,LOCTR)
         STRING (GENERATE,AR_MODE,LOCTR)

  The AR_MODE option can be specified to generate a @STRING module
  supports AR mode (This is the default).  Example:

         STRING (GENERATE,AR_MODE)

  The NO_CSECT option can be specified to indicate that the
  @STRING module should not be generated; only the literals
  are generated in this case.  Example:

         STRING (GENERATE,NO_CSECT)

  The @STRING CSECT contains optional functions (such as %TIME or
  julian date conversion) that are only generated if they have
  been specified in the previous invocations of the STRING macro.

  To generate of a @STRING CSECT that supports all of the optional
  functions, two STRING GENERATE macros must be specified:

         STRING (GENERATE,NO_CSECT)        Generate Literals
         STRING GENERATE                   Generate CSECT

Examples:

     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA

     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)

     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE

     LA    R5,WORK+16              end addr +1
     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN

     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)

     PUT31 SYSLIN
     LH    R0,SYSLIN+82            LRECL
     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))

     STRING GENERATE         Generate literals and sub-routine


Programming Notes:

  A STRING macro generates only 6 bytes that need to be covered by
  base registers.  More code is generated at the end of the
  current CSECT (using LOCTR pseudo instruction), but this code
  does not require addressability.  This is particularly useful
  when STRING calls specify a large number of literals.

  Additionally, STRING does not use A-type constants (ACON), but
  S-type constants (SCON) which require symbols to be addressable
  at the point in the program where STRING is issued.

  While this reduces the number of base registers required to
  cover the program's code and makes it easier to write reentrant
  programs, it will produce assembly errors in the following
  situations:

  a.  STRING is used in more than one CSECT in the same assembly

  b.  the CSECT in which STRING is used is longer than 64K

  c.  symbols are not addressable at the point in the program
      where STRING is issued

  d.  the $STRING symbol (generated in the $LTORG LOCTR during the
      GENERATE invocation of the STRING macro) is not addressable
      in some of the STRING calls.
